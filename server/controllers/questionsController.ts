import { RequestHandler } from 'express';
import subQuestionsModel from '../models/subQuestionSchema';
import { Authorized } from '../types/jwt';
import questionModel from '../models/questionSchema';
import { IError } from '../types/IError';
import { SubQuestionTypes } from '../types/models/IQuestion';
import { SubTypeQuestions } from '../types/models/ISubQuestion';
import { Types } from 'mongoose';
/**
 * @api {post} /question/create/main Create main question
 * @apiName createMainQuestion
 * @apiGroup Questions
 *
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"questionText":"main question",
 * 	"file":\\form data image,
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "questionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { questionText, pdfs, images } = req.body;
		console.log(images, pdfs);
		console.log(req.body);
		const teacherId = req.user?.id;
		const question = new questionModel({
			teacherId,
			question: questionText,
			image: images === undefined ? images : `media/images/${images}`,
			info: pdfs === undefined ? pdfs : `media/pdfs/${pdfs}`,
		});
		await question.save();
		res.status(200).json({ questionId: question._id });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {post} /question/create/sub Create sub question
 * @apiName createSubQuestion
 * @apiGroup Questions
 * @apiDescription It will accept tag values of only 5 specific values
 * The 5 values are:
 * 1. functional
 * 2. qualitative
 * 3. quantitative
 * 4. calculation
 * 5. evaluation
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"tag":"tag of the que",
 * 	"value":"Questioon value",
 * 	"questions":[
 * 		{
 * 		"question":"Question 1",
 * 		"answer":"Answer 1"
 * 		},
 * 		{
 * 		"question":"Question2",
 * 		"answer":"Answer 2"
 * 		}
 * 		... Upto 5
 * ]
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "subQuestionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createSubQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { type, questions, questionId, question } = req.body;
		if (!Object.values(SubQuestionTypes).includes(type)) {
			return res.status(401).json({ message: 'Invalid type' });
		}
		let questionIds: Array<Types.ObjectId> = [];
		let newQuestion;
		await questions.forEach(async (element: SubTypeQuestions) => {
			newQuestion = new subQuestionsModel({
				subtype: element.subtype,
				subQuestions: element.subQuestions,
			});
			questionIds.push(newQuestion._id);
			newQuestion.save();
		});
		const pull = await questionModel.findByIdAndUpdate(questionId, {
			$pull: { subQuestions: { tag: type } },
		});
		const subquestionstoremove = pull?.subQuestions.filter(
			(subQuestions) => {
				return subQuestions.tag === type;
			},
		);
		if (subquestionstoremove?.length || 0 > 0) {
			await subQuestionsModel.deleteMany({
				_id: { $in: subquestionstoremove![0].SubQuestions },
			});
		}
		const statusCheck = await questionModel.findByIdAndUpdate(questionId, {
			$push: {
				subQuestions: {
					SubQuestions: questionIds,
					tag: type,
					question: question,
				},
			},
		});
		console.log(statusCheck?.subQuestions.length);
		if (statusCheck?.subQuestions.length === 3) {
			console.log('complete');
			await questionModel.findByIdAndUpdate(questionId, {
				$set: { status: 'complete' },
			});
		}
		res.status(200).json({ message: 'Successfully saved' });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/student Get main questions for students
 * @apiName getMainQuestionsfroStudent
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 */
export const getMainQuestionsforStudent: RequestHandler = async (
	req,
	res,
	next,
) => {
	try {
		const questions = await questionModel.find({ status: 'complete' });
		res.status(200).json({ questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/teacher Get main questions made by teacher
 * @apiName getMainQuestionsforTeacher
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const getMainQuestionsforTeacher: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const teacherId = req.user?.id;
		const questions = await questionModel.find({ teacherId });
		res.status(200).json({ questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/sub Get sub questions
 * @apiName getSubQuestions
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 * @apiQuery {String} questionId The main question Id to retrieve the sub questions
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Student
 */
export const getSubquestions: RequestHandler = async (req, res, next) => {
	try {
		const { questionId, tag, subtype } = req.query;
		if (!questionId && !tag && !subtype) {
			throw new IError('Provide proper query params', 400);
		}
		if (
			!Object.values(SubQuestionTypes).includes(tag as SubQuestionTypes)
		) {
			throw new IError('Invalid tag', 401);
		}
		const subQuestions = await questionModel
			.findById(questionId)
			.populate('subQuestions.SubQuestions');
		const arr = subQuestions?.subQuestions.filter((questions) => {
			return questions.tag === tag;
		});
		//@ts-ignore
		const array = arr[0]?.SubQuestions.filter((subQuestions) => {
			//@ts-ignore
			return subQuestions.subtype === subtype;
		});
		res.status(200).json({
			//@ts-ignore
			questions: array[0].subQuestions,
			mainQuestion: subQuestions?.question,
			//@ts-ignore
			subQuestion: arr[0].question,
		});
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/edit/main Edit main question
 * @apiName geditMainQuestions
 * @apiGroup Questions
 * @apiSuccess {String} Success
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 * @apiBody {Object} Object of the values to be updated
 * @apiSuccessExample {json} body
 * {
 * 	"questionText":"New question?",
 * 	"bannerImage":"newphoto.jpg"
 * }
 */
export const editMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const questionId = req.query.questionId;
		const { questionText, bannerImage } = req.body;
		await questionModel.findByIdAndUpdate(questionId, {
			questionText,
			bannerImage,
		});
		res.status(200).json({ message: 'Success' });
	} catch (error) {
		next(error);
	}
};

export const getMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const questionId = req.query.questionId;
		const question = await questionModel.findById(questionId);
		res.status(200).json({ question });
	} catch (error) {
		next(error);
	}
};
