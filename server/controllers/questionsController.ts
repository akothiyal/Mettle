import { RequestHandler } from 'express';
import subQuestionsModel from '../models/subQuestionSchema';
import { Authorized } from '../types/jwt';
import questionModel from '../models/questionSchema';
import { IError } from '../types/IError';
import { SubQuestionTypes } from '../types/models/IQuestion';
import { SubTypeQuestions } from '../types/models/ISubQuestion';
import { Types } from 'mongoose';
/**
 * @api {post} /question/create/main Create main question
 * @apiName createMainQuestion
 * @apiGroup Questions
 *
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"questionText":"main question",
 * 	"file":\\form data image,
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "questionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { questionText, filename } = req.body;
		const teacherId = req.user?.id;
		const question = new questionModel({
			teacherId,
			question: questionText,
			image: filename,
		});
		await question.save();
		res.status(200).json({ questionId: question._id });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {post} /question/create/sub Create sub question
 * @apiName createSubQuestion
 * @apiGroup Questions
 * @apiDescription It will accept tag values of only 5 specific values
 * The 5 values are:
 * 1. functional
 * 2. qualitative
 * 3. quantitative
 * 4. calculation
 * 5. evaluation
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"tag":"tag of the que",
 * 	"value":"Questioon value",
 * 	"questions":[
 * 		{
 * 		"question":"Question 1",
 * 		"answer":"Answer 1"
 * 		},
 * 		{
 * 		"question":"Question2",
 * 		"answer":"Answer 2"
 * 		}
 * 		... Upto 5
 * ]
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "subQuestionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createSubQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { type, questions, questionId, question } = req.body;
		if (!Object.values(SubQuestionTypes).includes(type)) {
			return res.status(401).json({ message: 'Invalid type' });
		}
		let questionIds: Array<Types.ObjectId> = [];
		let newQuestion;
		await questions.forEach(
			async (element: SubTypeQuestions, index: number) => {
				newQuestion = new subQuestionsModel({
					subtype: element.subtype,
					subQuestions: element.subQuestions,
				});
				questionIds.push(newQuestion._id);
				newQuestion.save();
			},
		);
		await questionModel.findByIdAndUpdate(questionId, {
			$push: {
				subQuestions: {
					SubQuestions: questionIds,
					tag: type,
					question: question,
				},
			},
		});
		res.status(200).json({ message: 'Successfully saved' });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/student Get main questions for students
 * @apiName getMainQuestionsfroStudent
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 */
export const getMainQuestionsforStudent: RequestHandler = async (
	req,
	res,
	next,
) => {
	try {
		const questions = await questionModel.find();
		res.status(200).json({ questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/teacher Get main questions made by teacher
 * @apiName getMainQuestionsforTeacher
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const getMainQuestionsforTeacher: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const teacherId = req.user?.id;
		const questions = await questionModel.find({ teacherId });
		res.status(200).json({ questions: questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/sub Get sub questions
 * @apiName getSubQuestions
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 * @apiQuery {String} questionId The main question Id to retrieve the sub questions
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Student
 */
export const getSubquestions: RequestHandler = async (req, res, next) => {
	try {
		const questionId = req.query.questionId;
		if (!questionId) {
			throw new IError('No  question Id', 404);
		}
		const subQuestions = await questionModel
			.findById(questionId)
			.populate('subQuestions');
		res.status(200).json(subQuestions);
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/edit/main Edit main question
 * @apiName geditMainQuestions
 * @apiGroup Questions
 * @apiSuccess {String} Success
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 * @apiBody {Object} Object of the values to be updated
 * @apiSuccessExample {json} body
 * {
 * 	"questionText":"New question?",
 * 	"bannerImage":"newphoto.jpg"
 * }
 */
export const editMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const questionId = req.query.questionId;
		const { questionText, bannerImage } = req.body;
		await questionModel.findByIdAndUpdate(questionId, {
			questionText,
			bannerImage,
		});
		res.status(200).json({ message: 'Success' });
	} catch (error) {
		next(error);
	}
};
//TODO: Add docs and test
export const editSubQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const subQuestionId = req.query.subquestionId;
		const { subQuestion } = req.body;
		await subQuestionsModel.findByIdAndUpdate(subQuestionId, subQuestion);
		res.status(200).json({ message: 'Success' });
	} catch (error) {
		next(error);
	}
};
