import { RequestHandler } from 'express';
import subQuestionsModel from '../models/subQuestionSchema';
import { Authorized } from '../types/jwt';
import questionModel from '../models/questionSchema';
import { IError } from '../types/IError';
import { SubQuestionTypes } from '../types/models/IQuestion';
import { SubTypeQuestions } from '../types/models/ISubQuestion';
import { Types } from 'mongoose';
import fs from 'fs';
/**
 * @api {post} /question/create/main Create main question
 * @apiName createMainQuestion
 * @apiGroup Questions
 *
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"questionText":"main question",
 * 	"file":\\form data image,
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "questionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { questionText, pdfs, images } = req.body;
		const teacherId = req.user?.id;
		const question = new questionModel({
			teacherId,
			question: questionText,
			image: images === undefined ? images : `media/images/${images}`,
			info: pdfs === undefined ? pdfs : `media/pdfs/${pdfs}`,
		});
		await question.save();
		res.status(200).json({ questionId: question._id });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {post} /question/create/sub Create sub question
 * @apiName createSubQuestion
 * @apiGroup Questions
 * @apiDescription It will accept tag values of only 5 specific values
 * The 5 values are:
 * 1. functional
 * 2. qualitative
 * 3. quantitative
 * 4. calculation
 * 5. evaluation
 * @apiBody {Object} Body with some properties
 * @apiExample {json} body
 * {
 * 	"tag":"tag of the que",
 * 	"value":"Questioon value",
 * 	"questions":[
 * 		{
 * 		"question":"Question 1",
 * 		"answer":"Answer 1"
 * 		},
 * 		{
 * 		"question":"Question2",
 * 		"answer":"Answer 2"
 * 		}
 * 		... Upto 5
 * ]
 * }
 *
 *
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "subQuestionId":"ydsfusvcedewg2632egdvcdc"
 *     }
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const createSubQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const { type, questions, questionId, question } = req.body;
		if (!Object.values(SubQuestionTypes).includes(type)) {
			return res.status(401).json({ message: 'Invalid type' });
		}

		// If the "Calculation" type has no mini-questions
		if (
			type === SubQuestionTypes.Calculation &&
			(!questions || questions.length === 0)
		) {
			// Create a subquestion without mini-questions
			const newQuestion = new subQuestionsModel({
				subtype: type,
			});

			// Save the subquestion
			await newQuestion.save();
			// Add the new "Calculation" subquestion to the question document
			const statusCheck = await questionModel.findByIdAndUpdate(
				questionId,
				{
					$push: {
						subQuestions: {
							SubQuestions: [newQuestion._id],
							tag: type,
							question: question,
						},
					},
				},
			);

			// Check if the question has three subquestions and update the status if needed
			if (statusCheck?.subQuestions.length === 3) {
				await questionModel.findByIdAndUpdate(questionId, {
					$set: { status: 'complete' },
				});
			}
		} else {
			// For other types or "Calculation" type with mini-questions
			let questionIds: Array<Types.ObjectId> = [];
			await questions.forEach(async (element: SubTypeQuestions) => {
				const newQuestion = new subQuestionsModel({
					subtype: element.subtype,
					subQuestions: element.subQuestions,
				});
				questionIds.push(newQuestion._id);
				await newQuestion.save();
			});

			const pull = await questionModel.findByIdAndUpdate(questionId, {
				$pull: { subQuestions: { tag: type } },
			});

			const subquestionstoremove = pull?.subQuestions.filter(
				(subQuestions) => subQuestions.tag === type,
			);

			if (subquestionstoremove?.length || 0 > 0) {
				await subQuestionsModel.deleteMany({
					_id: { $in: subquestionstoremove![0].SubQuestions },
				});
			}

			const statusCheck = await questionModel.findByIdAndUpdate(
				questionId,
				{
					$push: {
						subQuestions: {
							SubQuestions: questionIds,
							tag: type,
							question: question,
						},
					},
				},
			);

			if (statusCheck?.subQuestions.length === 3) {
				await questionModel.findByIdAndUpdate(questionId, {
					$set: { status: 'complete' },
				});
			}
		}

		res.status(200).json({ message: 'Successfully saved' });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/student Get main questions for students
 * @apiName getMainQuestionsfroStudent
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 */
export const getMainQuestionsforStudent: RequestHandler = async (
	req,
	res,
	next,
) => {
	try {
		const questions = await questionModel.find({ status: 'complete' });
		res.status(200).json({ questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/main/teacher Get main questions made by teacher
 * @apiName getMainQuestionsforTeacher
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 *
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 */
export const getMainQuestionsforTeacher: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const teacherId = req.user?.id;
		const questions = await questionModel.find({ teacherId });
		res.status(200).json({ questions });
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/sub Get sub questions
 * @apiName getSubQuestions
 * @apiGroup Questions
 * @apiSuccess {Array} Array of all the questions
 * @apiQuery {String} questionId The main question Id to retrieve the sub questions
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Student
 */
export const getSubquestions: RequestHandler = async (req, res, next) => {
	try {
		const { questionId, tag, subtype } = req.query;
		if (!questionId && !tag && !subtype) {
			throw new IError('Provide proper query params', 400);
		}
		if (
			!Object.values(SubQuestionTypes).includes(tag as SubQuestionTypes)
		) {
			throw new IError('Invalid tag', 401);
		}
		const subQuestions = await questionModel
			.findById(questionId)
			.populate('subQuestions.SubQuestions');
		const arr = subQuestions?.subQuestions.filter((questions) => {
			return questions.tag === tag;
		});
		//@ts-ignore
		const array = arr[0]?.SubQuestions.filter((subQuestions) => {
			//@ts-ignore
			return subQuestions.subtype === subtype;
		});
		res.status(200).json({
			//@ts-ignore
			questions: array[0].subQuestions,
			mainQuestion: subQuestions?.question,
			//@ts-ignore
			subQuestion: arr[0].question,
		});
	} catch (error) {
		next(error);
	}
};
/**
 * @api {get} /question/edit/main Edit main question
 * @apiName geditMainQuestions
 * @apiGroup Questions
 * @apiSuccess {String} Success
 *
 * @apiHeader {String} Authorization JWT token generated by the server
 * @apiHeaderExample {json} Token-example
 * 		{
 * 			"Authorization":"Bearer srfv27635retdyucj2beyruhcbdhf"
 * 		}
 * @apiPermission Teacher
 * @apiBody {Object} Object of the values to be updated
 * @apiSuccessExample {json} body
 * {
 * 	"questionText":"New question?",
 * 	"bannerImage":"newphoto.jpg"
 * }
 */
export const editMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const questionId = req.query.questionId;
		const { question, images, pdfs } = req.body;
		const questionDetails = await questionModel.findByIdAndUpdate(
			questionId,
			{
				$set: {
					question,
					image: images,
					info: pdfs,
				},
			},
		);
		if (!questionDetails) {
			throw new IError('Question to be editted not found', 404);
		}
		const imagePath = questionDetails?.image;
		const pdfPath = questionDetails?.info;
		if (images) {
			fs.rmSync(imagePath);
		}
		if (pdfs) {
			fs.rmSync(pdfPath);
		}
		res.status(200).json({ message: 'Success' });
	} catch (error) {
		next(error);
	}
};

export const getMainQuestion: RequestHandler = async (
	req: Authorized,
	res,
	next,
) => {
	try {
		const questionId = req.query.questionId;
		const question = await questionModel.findById(questionId);
		res.status(200).json({ question });
	} catch (error) {
		next(error);
	}
};

